# -*- coding: utf-8 -*-
"""trabalhofinal.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WVRGyicOBqUhXHRgtBsLXWGUjiuHT4Ty

# Trabalho Final IA
Renata Moura Barreto

Para os algoritmos rodarem é preciso rodar um por vez

#**Bibliotecas**
"""

# Commented out IPython magic to ensure Python compatibility.
#bibliotecas

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib_venn import venn2
import seaborn as sns
from ast import literal_eval
from sklearn.neighbors import NearestNeighbors
from sklearn.feature_extraction.text import TfidfVectorizer
import time
from sklearn.metrics.pairwise import cosine_distances
from sklearn.metrics.pairwise import linear_kernel
from gensim.models import Word2Vec
from sklearn.metrics.pairwise import cosine_similarity
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten

# %matplotlib inline

"""#Leitura do Dataset"""

#leitura dos datasets
recipes = pd.read_csv('/content/drive/MyDrive/ia/RAW_recipes.csv')

"""# Análise dos Dados"""

#vendo as primeiras receitas
recipes.head()

#análise das informações do dataset

print(recipes.info())

"""#Manipulando Dados"""

#retirando as receitas que não são vegetarianas ou veganas

veg = ['vegetarian', 'vegan']

df = recipes[recipes['tags'].str.contains('|'.join(veg))]

#analisando as receitas que sobraram
print(df.info())
df.head(5)

#análise dos minutos

sns.scatterplot(x='id', y='minutes', data= df)
plt.legend(bbox_to_anchor=(1, 1), loc=2)
plt.show()

#retirando as receitas que demoram mais de um dia para serem feitas

df = df.query('minutes < 1440')

#vendo as receitas que sobraram
print(df.info())

"""# **Input**

"""

#input para saber o nome do usuário
name = input("Hello, my name is Vegia. I'm here to help you make delicious recipes. What's your name? ")

#input para saber os ingredientes do usuário

user_ingredients = []

print(f"Welcome {name}! Enter the ingredients you have, separated by commas: ")

user_input = input("Example:\nbanana,apple,lemon\n")

user_ingredients.extend(user_input.split(','))

print("List of ingredients:", user_ingredients)

"""#**Algoritmos de recomendação**

##KNN
"""

#tempo de início
start_time = time.time()

# início do vetorizador TF-IDF
# min_df=1-> inclui todos os ingredientes
# stop_words=None -> não remove stop words
vectorizer = TfidfVectorizer(min_df=1, stop_words=None)

#fit_transform -> transforma a lista de ingredientes em uma matriz TF-IDF
matrix = vectorizer.fit_transform(df['ingredients'])

# vizinhos = 5
# método =  "força bruta" para encontrar os vizinhos mais próximos.
# métrica= distâncias dos cossenos
knn_model = NearestNeighbors(n_neighbors=5, algorithm='brute', metric='cosine')

#ajuste
knn_model.fit(matrix)

#transforma os ingredientes em um vetor TF-IDF
vector = vectorizer.transform([' '.join(user_ingredients)])

#kneighbors -> procura os vizinhos mais próximos
distances, indices = knn_model.kneighbors(vector)

#tempo final
end_time = time.time()

#impressão das receitas
print("Recipes:")
for i, idx in enumerate(indices.flatten()):
    recipe_info = df.iloc[idx]
    print(f"\n{i + 1}. Name: {recipe_info['name']}")
    print(f"⟶ Cooking time: {recipe_info['minutes']} minutes")
    print("⟶ Ingredients:")
    print(f"   {recipe_info['ingredients']}")
    print("⟶ Steps:")
    print(f"   {recipe_info['steps']}\n")
    print("-"*40)

#calculo do tempo de execução
total_time = end_time - start_time

print(f"Execution time: {total_time} seconds")

"""##Processamento de linguagem natural e medidas de similaridade


"""

start_time = time.time()

# cria matriz TF-IDF
vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = vectorizer.fit_transform(df['ingredients'].apply(lambda x: ' '.join(eval(x))))

# representação TF-IDF
user_tfidf = vectorizer.transform([' '.join(user_ingredients)])

# calculo da similaridade de Jaccard entre os ingredientes do usuário e as receitas
cosine_similarities = linear_kernel(user_tfidf, tfidf_matrix).flatten()

# índices das receitas mais similares
recipe_indices = cosine_similarities.argsort()[:-6:-1]
end_time = time.time()

# impressão
print("\nRecipes:")
for idx in recipe_indices:
    print(df['name'].iloc[idx])

total_time = end_time - start_time

print(f"Tempo decorrido: {total_time} segundos")

"""##tentativa de rede neural"""

start_time = time.time()
#strings de ingredientes em listas de palavras
list_ingredients = df['ingredients'].apply(lambda x: eval(x))

#treina um modelo Word2Vec na lista de ingredientes
word2vec_model = Word2Vec(sentences= list_ingredients, vector_size=100, window=5, min_count=1, workers=4)

# calculaa o vetor médio dos ingredientes de uma receita
def get_vector(recipe_ingredients):
    vectors = [word2vec_model.wv[word] for word in recipe_ingredients if word in word2vec_model.wv]
    return np.mean(vectors, axis=0) if vectors else np.zeros(word2vec_model.vector_size)

# chama a função "get_vector" para as listas de ingredientes
# salva coluna chamada "recipe_vector"
df['recipe_vector'] = list_ingredients.apply(get_vector)

#chama a a função get_vector e cria um vetor médio para os ingredientes do usuário
user_vector = get_vector(user_ingredients)

# rede neural sequencial
#camada 1: entrada com 100 neurônios
#camada 2: 50 neurônios
#camada 3:1 neurônio usando a função de ativação sigmoid(normaliza a saída entre 0 e 1)
model = Sequential([
    Dense(100, input_dim=word2vec_model.vector_size, activation='relu'),
    Dense(50, activation='relu'),
    Dense(1, activation='sigmoid')
])

#compila o modelo: otimizador = adam e  função de perda
model.compile(optimizer='adam', loss='binary_crossentropy')

# treina o modelo com 10 épocas usando os vetores de receitas
#usa similaridade de cosseno com os ingredientes do usuário
X_train = np.vstack(df['recipe_vector'])
y_train = cosine_similarity(X_train, [user_vector]).flatten()
model.fit(X_train, y_train, epochs=10, batch_size=32, verbose=0)

#calcula a similaridade entre os ingredientes do usuário e as receitas
user_similarity = model.predict(user_vector.reshape(1, -1))

# classifica de acordo com "user_similarity"
#seleciona as 5 receitas mais similares
df['user_similarity'] = model.predict(np.vstack(df['recipe_vector']))
top_recipes = df.sort_values(by='user_similarity', ascending=False).head(5)

end_time = time.time()

print("\nRecipes:")

for _, row in top_recipes.iterrows():
    print(f"\nName: {row['name']}")
    print(f"⟶ Cooking time:{row['minutes']} minutes")
    print(f"⟶ Number of Ingredients:{row['n_ingredients']} ingredients")
    print("⟶ Ingredients:\n   ", row['ingredients'])
    print(f"⟶ Steps:\n  {row['steps']}\n")
    print("-" * 40)

total_time = end_time - start_time

print(f"Tempo decorrido: {total_time} segundos")